(function(c,h){typeof exports=="object"&&typeof module<"u"?h(exports,require("@dzangolab/fastify-mercurius"),require("fastify-plugin"),require("mercurius"),require("mercurius-auth"),require("@fastify/cors"),require("@fastify/formbody"),require("supertokens-node"),require("supertokens-node/framework/fastify"),require("supertokens-node/recipe/session/framework/fastify"),require("supertokens-node/recipe/session"),require("supertokens-node/recipe/thirdpartyemailpassword"),require("supertokens-node/recipe/userroles"),require("@dzangolab/fastify-slonik"),require("@dzangolab/fastify-mailer"),require("validator"),require("zod")):typeof define=="function"&&define.amd?define(["exports","@dzangolab/fastify-mercurius","fastify-plugin","mercurius","mercurius-auth","@fastify/cors","@fastify/formbody","supertokens-node","supertokens-node/framework/fastify","supertokens-node/recipe/session/framework/fastify","supertokens-node/recipe/session","supertokens-node/recipe/thirdpartyemailpassword","supertokens-node/recipe/userroles","@dzangolab/fastify-slonik","@dzangolab/fastify-mailer","validator","zod"],h):(c=typeof globalThis<"u"?globalThis:c||self,h(c.DzangolabFastifyUser={},c.DzangolabFastifyMercurius,c.FastifyPlugin,c.Mercurius,c.MercuriusAuth,c.FastifyCors,c.FastifyFormbody,c.SupertokensNode,c.SupertokensFastify,c.SupertokensSessionFastify,c.SupertokensSession,c.SupertokensThirdPartyEmailPassword,c.SupertokensUserRoles,c.DzangolabFastifySlonik,c.DzangolabFastifyMailer,c.validator,c.zod))})(this,function(c,h,S,P,C,N,D,U,v,L,y,d,p,R,ue,O,k){"use strict";const q=S(async e=>{e.config.mercurius.enabled&&e.register(C,{async applyPolicy(n,r,t,i){if(!i.user){const o=new P.ErrorWithProps("unauthorized");return o.statusCode=200,o}return!0},authDirective:"auth"})}),_=()=>({override:{functions:function(e){return{...e,createNewSession:async function(s){return s.accessTokenPayload={...s.accessTokenPayload,user:await d.getUserById(s.userId)},e.createNewSession(s)}}}}}),T=e=>{const s=e.config.user.supertokens.recipes;return s&&s.session?y.init(s.session(e)):y.init(_())};class A extends R.DefaultSqlFactory{}class g extends R.BaseService{static LIMIT_DEFAULT=20;static LIMIT_MAX=50;get table(){return this.config.user?.table?.name||"users"}get factory(){if(!this.table)throw new Error("Service table is not defined");return this._factory||(this._factory=new A(this)),this._factory}}const M=(e,s)=>{const{config:n,slonik:r}=s;return async t=>{const i=await e.emailPasswordSignIn(t);if(i.status!=="OK")return i;const o=new g(n,r);let a=null;try{a=await o.findById(i.user.id)}catch{}const{roles:u}=await p.getRolesForUser(i.user.id);return{status:"OK",user:{...i.user,profile:a,roles:u}}}},E=async({fastify:e,subject:s,templateData:n={},templateName:r,to:t})=>{const{config:i,mailer:o,log:a}=e;return o.sendMail({subject:s,templateName:r,to:t,templateData:{appName:i.appName,...n}}).catch(u=>{throw a.error(u.stack),{name:"SEND_EMAIL",message:u.message,statusCode:500}})},$=(e,s)=>{const{config:n,log:r}=s;return async t=>{if(n.user.features?.signUp===!1)throw{name:"SIGN_UP_DISABLED",message:"SignUp feature is currently disabled",statusCode:404};const i=await e.emailPasswordSignUp(t);if(i.status==="OK"){const o=await p.addRoleToUser(i.user.id,n.user.role||"USER");o.status!=="OK"&&r.error(o.status)}if(n.user.supertokens.sendUserAlreadyExistsWarning&&i.status==="EMAIL_ALREADY_EXISTS_ERROR")try{await E({fastify:s,subject:"Duplicate Email Registration",templateData:{emailId:t.email},templateName:"duplicate-email-warning",to:t.email})}catch(o){r.error(o)}return i}},B=(e,s)=>async n=>{if(e.emailPasswordSignUpPOST===void 0)throw new Error("Should never come here");const r=await e.emailPasswordSignUpPOST(n);if(r.status==="OK"){const{roles:t}=await p.getRolesForUser(r.user.id);return{status:"OK",user:{...r.user,profile:null,roles:t},session:r.session}}return r},z=e=>{let s;try{if(s=new URL(e).origin,!s||s==="null")throw new Error("Origin is empty")}catch{s=""}return s},K=(e,s)=>{const n=s.config.appOrigin[0],r="/reset-password";return async t=>{const i=t.userContext._default.request.request,o=i.headers.referer||i.headers.origin||i.hostname,a=z(o)||n,u=t.passwordResetLink.replace(n+"/auth/reset-password",a+(s.config.user.supertokens.resetPasswordPath||r));await E({fastify:s,subject:"Reset Password",templateName:"reset-password",to:t.user.email,templateData:{passwordResetLink:u}})}},j=(e,s)=>{const{config:n,log:r}=s;return async t=>{if(!await d.getUserByThirdPartyInfo(t.thirdPartyId,t.thirdPartyUserId,t.userContext)&&n.user.features?.signUp===!1)throw{name:"SIGN_UP_DISABLED",message:"SignUp feature is currently disabled",statusCode:404};const o=await e.thirdPartySignInUp(t);if(o.status==="OK"){const a=await p.addRoleToUser(o.user.id,n.user.role||"USER");a.status!=="OK"&&r.error(a.status)}return o}},H=(e,s)=>async n=>{if(e.thirdPartySignInUpPOST===void 0)throw new Error("Should never come here");const r=await e.thirdPartySignInUpPOST(n);if(r.status==="OK"&&r.createdNewUser){const{roles:t}=await p.getRolesForUser(r.user.id),i={...r.user,profile:null,roles:t};return{status:"OK",createdNewUser:r.createdNewUser,user:i,session:r.session,authCodeResponse:r.authCodeResponse}}return r},J=e=>{const{Apple:s,Facebook:n,Github:r,Google:t}=d,i=e.user.supertokens.providers,o=[],a=[{name:"google",initProvider:t},{name:"github",initProvider:r},{name:"facebook",initProvider:n},{name:"apple",initProvider:s}];for(const u of a)i?.[u.name]&&o.push(u.initProvider(i[u.name]));return o},W=(e,s)=>k.z.string({required_error:e.required}).refine(n=>O.isEmail(n,s||{}),{message:e.invalid}),b={minLength:8,minLowercase:0,minUppercase:0,minNumbers:0,minSymbols:0,returnScore:!1,pointsPerUnique:1,pointsPerRepeat:.5,pointsForContainingLower:10,pointsForContainingUpper:10,pointsForContainingNumber:10,pointsForContainingSymbol:10},G=(e,s)=>{const n={...b,...s};return k.z.string({required_error:e.required}).refine(r=>O.isStrongPassword(r,n),{message:e.weak})},Q=(e,s)=>{const n=W({invalid:"Email is invalid",required:"Email is required"},s.user.email).safeParse(e);return n.success?{success:!0}:{message:n.error.issues[0].message,success:!1}},V=e=>{let s="Password is too weak";if(!e)return s;const n=[];if(e.minLength){const r=e.minLength;n.push(`minimum ${r} ${r>1?"characters":"character"}`)}if(e.minLowercase){const r=e.minLowercase;n.push(`minimum ${r} ${r>1?"lowercases":"lowercase"}`)}if(e.minUppercase){const r=e.minUppercase;n.push(`minimum ${r} ${r>1?"uppercases":"uppercase"}`)}if(e.minNumbers){const r=e.minNumbers;n.push(`minimum ${r} ${r>1?"numbers":"number"}`)}if(e.minSymbols){const r=e.minSymbols;n.push(`minimum ${r} ${r>1?"symbols":"symbol"}`)}if(n.length>0){s="Password should contain ";const r=n.pop();n.length>0&&(s+=n.join(", ")+" and "),s+=r}return s},I=(e,s)=>{const n=s.user.password,r=G({required:"Password is required",weak:V({...b,...n})},n).safeParse(e);return r.success?{success:!0}:{message:r.error.issues[0].message,success:!1}},X=e=>{const{config:s}=e,n=s.user.supertokens.recipes?.thirdPartyEmailPassword;return{override:{apis:r=>{const t={};if(typeof n=="object"&&n.override?.apis){const i=n.override.apis;let o;for(o in i){const a=i[o];a&&(t[o]=a(r,e))}}return{...r,emailPasswordSignUpPOST:B(r),thirdPartySignInUpPOST:H(r),...t}},functions:r=>{const t={};if(typeof n=="object"&&n.override?.function){const i=n.override.function;let o;for(o in i){const a=i[o];a&&(t[o]=a(r,e))}}return{...r,emailPasswordSignIn:M(r,e),emailPasswordSignUp:$(r,e),thirdPartySignInUp:j(r,e),...t}}},signUpFeature:{formFields:[{id:"email",validate:async r=>{const t=Q(r,s);if(!t.success)return t.message}},{id:"password",validate:async r=>{const t=I(r,s);if(!t.success)return t.message}}]},emailDelivery:{override:r=>{let t;return typeof n=="object"&&typeof n?.sendEmail=="function"&&(t=n.sendEmail),{...r,sendEmail:t?t(r,e):K(r,e)}}},providers:J(s)}},Y=e=>{const s=e.config.user.supertokens.recipes?.thirdPartyEmailPassword;return s&&typeof s=="function"?d.init(s(e)):d.init(X(e))},Z=()=>({}),x=e=>{const s=e.config.user.supertokens.recipes;return s&&s.userRoles?p.init(s.userRoles(e)):p.init(Z())},ee=e=>[T(e),Y(e),x(e)],se=e=>{const{config:s}=e;U.init({appInfo:{apiDomain:s.baseUrl,appName:s.appName,websiteDomain:s.appOrigin[0]},recipeList:ee(e),supertokens:{connectionURI:s.user.supertokens.connectionUri}})},re=S(async(e,s,n)=>{const{config:r,log:t}=e;t.info("Registering supertokens plugin"),se(e),e.setErrorHandler(v.errorHandler()),e.register(N,{origin:r.appOrigin,allowedHeaders:["Content-Type","st-auth-mode",...U.getAllCORSHeaders()],credentials:!0}),e.register(D),e.register(v.plugin),t.info("Registering supertokens plugin complete"),e.decorate("verifySession",L.verifySession),n()}),ne=async(e,s,n)=>{const{config:r,slonik:t}=s,o=(await y.getSession(s,v.wrapResponse(n),{sessionRequired:!1}))?.getUserId();if(o){const a=new g(r,t),u=await d.getUserById(o);if(u){let l=null;const{roles:f}=await p.getRolesForUser(o);try{l=await a.findById(o)}catch{}const m={...u,profile:l,roles:f};e.user=m}}},F=S(async(e,s,n)=>{const{mercurius:r}=e.config;await e.register(re),r.enabled&&await e.register(q),n()});F.updateContext=ne;const te={Query:{user:async(e,s,n)=>await new g(n.config,n.database).findById(s.id),users:async(e,s,n)=>await new g(n.config,n.database).list(s.limit,s.offset,s.filters?JSON.parse(JSON.stringify(s.filters)):void 0,s.sort?JSON.parse(JSON.stringify(s.sort)):void 0)}},ie=async(e,s,n)=>{const r="/users";e.get(r,{preHandler:e.verifySession()},async(t,i)=>{const o=new g(t.config,t.slonik),{limit:a,offset:u,filters:l,sort:f}=t.query,m=await o.list(a,u,l?JSON.parse(l):void 0,f?JSON.parse(f):void 0);i.send(m)}),n()};class w{config;database;constructor(s,n){this.config=s,this.database=n}changePassword=async(s,n,r)=>{const t=I(r,this.config);if(!t.success)return{status:"FIELD_ERROR",message:t.message};const i=await d.getUserById(s);if(n&&r)if(i)if((await d.emailPasswordSignIn(i.email,n)).status==="OK"){if(await d.updateEmailOrPassword({userId:s,password:r}))return await y.revokeAllSessionsForUser(s),{status:"OK"};throw{status:"FAILED",message:"Oops! Something went wrong, couldn't change password"}}else return{status:"INVALID_PASSWORD",message:"Invalid password"};else throw{status:"NOT_FOUND",message:"User not found"};else return{status:"FIELD_ERROR",message:"Password cannot be empty"}};getUserById=async s=>{const n=await d.getUserById(s),r=new g(this.config,this.database);let t=null;try{t=await r.findById(s)}catch{}const i=await p.getRolesForUser(s);return{email:n?.email,id:s,profile:t,roles:i.roles,timeJoined:n?.timeJoined}}}const oe={Mutation:{changePassword:async(e,s,n)=>{const r=new w(n.config,n.database);try{return n.user?.id?await r.changePassword(n.user?.id,s.oldPassword,s.newPassword):{status:"NOT_FOUND",message:"User not found"}}catch(t){n.app.log.error(t);const i=new P.ErrorWithProps("Oops, Something went wrong");return i.statusCode=500,i}}},Query:{me:async(e,s,n)=>{const r=new w(n.config,n.database);if(n.user?.id)return r.getUserById(n.user.id);{n.app.log.error("Cound not get user id from mercurius context");const t=new P.ErrorWithProps("Oops, Something went wrong");return t.statusCode=500,t}}}},ae=async(e,s,n)=>{const r="/change_password",t="/me";e.post(r,{preHandler:e.verifySession()},async(i,o)=>{try{const a=i.session,u=i.body,l=a&&a.getUserId();if(!l)throw new Error("User not found in session");const f=u.oldPassword??"",m=u.newPassword??"",ce=await new w(i.config,i.slonik).changePassword(l,f,m);o.send(ce)}catch(a){e.log.error(a),o.status(500),o.send({status:"ERROR",message:"Oops! Something went wrong",error:a})}}),e.get(t,{preHandler:e.verifySession()},async(i,o)=>{const a=new w(i.config,i.slonik),u=i.session?.getUserId();if(u)o.send(await a.getUserById(u));else throw e.log.error("Cound not get user id from session"),new Error("Oops, Something went wrong")}),n()};c.UserProfileService=g,c.UserService=w,c.default=F,c.userProfileResolver=te,c.userProfileRoutes=ie,c.userResolver=oe,c.userRoutes=ae,Object.defineProperties(c,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
