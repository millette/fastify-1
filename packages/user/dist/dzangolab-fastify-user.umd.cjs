(function(c,h){typeof exports=="object"&&typeof module<"u"?h(exports,require("@dzangolab/fastify-mercurius"),require("fastify-plugin"),require("mercurius"),require("mercurius-auth"),require("@fastify/cors"),require("@fastify/formbody"),require("supertokens-node"),require("supertokens-node/framework/fastify"),require("supertokens-node/recipe/session/framework/fastify"),require("supertokens-node/recipe/session"),require("supertokens-node/recipe/thirdpartyemailpassword"),require("supertokens-node/recipe/userroles"),require("@dzangolab/fastify-slonik"),require("@dzangolab/fastify-mailer"),require("validator"),require("zod")):typeof define=="function"&&define.amd?define(["exports","@dzangolab/fastify-mercurius","fastify-plugin","mercurius","mercurius-auth","@fastify/cors","@fastify/formbody","supertokens-node","supertokens-node/framework/fastify","supertokens-node/recipe/session/framework/fastify","supertokens-node/recipe/session","supertokens-node/recipe/thirdpartyemailpassword","supertokens-node/recipe/userroles","@dzangolab/fastify-slonik","@dzangolab/fastify-mailer","validator","zod"],h):(c=typeof globalThis<"u"?globalThis:c||self,h(c.DzangolabFastifyUser={},c.DzangolabFastifyMercurius,c.FastifyPlugin,c.Mercurius,c.MercuriusAuth,c.FastifyCors,c.FastifyFormbody,c.SupertokensNode,c.SupertokensFastify,c.SupertokensSessionFastify,c.SupertokensSession,c.SupertokensThirdPartyEmailPassword,c.SupertokensUserRoles,c.DzangolabFastifySlonik,c.DzangolabFastifyMailer,c.validator,c.zod))})(this,function(c,h,S,P,N,C,D,U,v,L,y,d,p,R,ue,O,k){"use strict";const q=S(async e=>{e.config.mercurius.enabled&&e.register(N,{async applyPolicy(r,n,t,i){if(!i.user){const o=new P.ErrorWithProps("unauthorized");return o.statusCode=200,o}return!0},authDirective:"auth"})}),_=()=>({override:{functions:function(e){return{...e,createNewSession:async function(s){return s.accessTokenPayload={...s.accessTokenPayload,user:await d.getUserById(s.userId)},e.createNewSession(s)}}}}}),T=e=>{const s=e.config.user.supertokens.recipes;return s&&s.session?y.init(s.session(e)):y.init(_())};class A extends R.DefaultSqlFactory{}class g extends R.BaseService{static LIMIT_DEFAULT=20;static LIMIT_MAX=50;get table(){return this.config.user?.table?.name||"users"}get factory(){if(!this.table)throw new Error("Service table is not defined");return this._factory||(this._factory=new A(this)),this._factory}}const M=(e,s)=>{const{config:r,slonik:n}=s;return async t=>{const i=await e.emailPasswordSignIn(t);if(i.status!=="OK")return i;const o=new g(r,n);let a=null;try{a=await o.findById(i.user.id)}catch{}const{roles:u}=await p.getRolesForUser(i.user.id);return{status:"OK",user:{...i.user,profile:a,roles:u}}}},E=async({fastify:e,subject:s,templateData:r={},templateName:n,to:t})=>{const{config:i,mailer:o,log:a}=e;return o.sendMail({subject:s,templateName:n,to:t,templateData:{appName:i.appName,...r}}).catch(u=>{throw a.error(u.stack),{name:"SEND_EMAIL",message:u.message,statusCode:500}})},$=(e,s)=>{const{config:r,log:n}=s;return async t=>{if(r.user.features?.signUp===!1)throw{name:"SIGN_UP_DISABLED",message:"SignUp feature is currently disabled",statusCode:404};const i=await e.emailPasswordSignUp(t);if(i.status==="OK"){const o=await p.addRoleToUser(i.user.id,r.user.role||"USER");o.status!=="OK"&&n.error(o.status)}if(r.user.supertokens.sendUserAlreadyExistsWarning&&i.status==="EMAIL_ALREADY_EXISTS_ERROR")try{await E({fastify:s,subject:"Duplicate Email Registration",templateData:{emailId:t.email},templateName:"duplicate-email-warning",to:t.email})}catch(o){n.error(o)}return i}},B=(e,s)=>async r=>{if(e.emailPasswordSignUpPOST===void 0)throw new Error("Should never come here");const n=await e.emailPasswordSignUpPOST(r);if(n.status==="OK"){const{roles:t}=await p.getRolesForUser(n.user.id);return{status:"OK",user:{...n.user,profile:null,roles:t},session:n.session}}return n},z=e=>{let s;try{if(s=new URL(e).origin,!s||s==="null")throw new Error("Origin is empty")}catch{s=""}return s},K=e=>{const s=e.config.appOrigin[0],r="/reset-password";return async n=>{const t=n.userContext._default.request.request,i=t.headers.referer||t.headers.origin||t.hostname,o=z(i)||s,a=n.passwordResetLink.replace(s+"/auth/reset-password",o+(e.config.user.supertokens.resetPasswordPath||r));await E({fastify:e,subject:"Reset Password",templateName:"reset-password",to:n.user.email,templateData:{passwordResetLink:a}})}},H=(e,s)=>{const{config:r,log:n}=s;return async t=>{if(!await d.getUserByThirdPartyInfo(t.thirdPartyId,t.thirdPartyUserId,t.userContext)&&r.user.features?.signUp===!1)throw{name:"SIGN_UP_DISABLED",message:"SignUp feature is currently disabled",statusCode:404};const o=await e.thirdPartySignInUp(t);if(o.status==="OK"){const a=await p.addRoleToUser(o.user.id,r.user.role||"USER");a.status!=="OK"&&n.error(a.status)}return o}},J=(e,s)=>async r=>{if(e.thirdPartySignInUpPOST===void 0)throw new Error("Should never come here");const n=await e.thirdPartySignInUpPOST(r);if(n.status==="OK"&&n.createdNewUser){const{roles:t}=await p.getRolesForUser(n.user.id),i={...n.user,profile:null,roles:t};return{status:"OK",createdNewUser:n.createdNewUser,user:i,session:n.session,authCodeResponse:n.authCodeResponse}}return n},j=e=>{const{Apple:s,Facebook:r,Github:n,Google:t}=d,i=e.user.supertokens.providers,o=[],a=[{name:"google",initProvider:t},{name:"github",initProvider:n},{name:"facebook",initProvider:r},{name:"apple",initProvider:s}];for(const u of a)i?.[u.name]&&o.push(u.initProvider(i[u.name]));return o},W=(e,s)=>k.z.string({required_error:e.required}).refine(r=>O.isEmail(r,s||{}),{message:e.invalid}),I={minLength:8,minLowercase:0,minUppercase:0,minNumbers:0,minSymbols:0,returnScore:!1,pointsPerUnique:1,pointsPerRepeat:.5,pointsForContainingLower:10,pointsForContainingUpper:10,pointsForContainingNumber:10,pointsForContainingSymbol:10},G=(e,s)=>{const r={...I,...s};return k.z.string({required_error:e.required}).refine(n=>O.isStrongPassword(n,r),{message:e.weak})},Q=(e,s)=>{const r=W({invalid:"Email is invalid",required:"Email is required"},s.user.email).safeParse(e);return r.success?{success:!0}:{message:r.error.issues[0].message,success:!1}},V=e=>{let s="Password is too weak";if(!e)return s;const r=[];if(e.minLength){const n=e.minLength;r.push(`minimum ${n} ${n>1?"characters":"character"}`)}if(e.minLowercase){const n=e.minLowercase;r.push(`minimum ${n} ${n>1?"lowercases":"lowercase"}`)}if(e.minUppercase){const n=e.minUppercase;r.push(`minimum ${n} ${n>1?"uppercases":"uppercase"}`)}if(e.minNumbers){const n=e.minNumbers;r.push(`minimum ${n} ${n>1?"numbers":"number"}`)}if(e.minSymbols){const n=e.minSymbols;r.push(`minimum ${n} ${n>1?"symbols":"symbol"}`)}if(r.length>0){s="Password should contain ";const n=r.pop();r.length>0&&(s+=r.join(", ")+" and "),s+=n}return s},b=(e,s)=>{const r=s.user.password,n=G({required:"Password is required",weak:V({...I,...r})},r).safeParse(e);return n.success?{success:!0}:{message:n.error.issues[0].message,success:!1}},X=e=>{const{config:s}=e;return{override:{apis:r=>{const n=s.user.supertokens.recipes?.thirdPartyEmailPassword;let t;typeof n=="object"&&(t=n?.override?.apis);const i={};if(t){let o;for(o in t){const a=t[o];a&&(i[o]=a(r,e))}}return{...r,emailPasswordSignUpPOST:B(r),thirdPartySignInUpPOST:J(r),...i}},functions:r=>{const n=s.user.supertokens.recipes?.thirdPartyEmailPassword;let t;typeof n=="object"&&(t=n?.override?.function);const i={};if(t){let o;for(o in t){const a=t[o];a&&(i[o]=a(r,e))}}return{...r,emailPasswordSignIn:M(r,e),emailPasswordSignUp:$(r,e),thirdPartySignInUp:H(r,e),...i}}},signUpFeature:{formFields:[{id:"email",validate:async r=>{const n=Q(r,s);if(!n.success)return n.message}},{id:"password",validate:async r=>{const n=b(r,s);if(!n.success)return n.message}}]},emailDelivery:{override:r=>({...r,sendEmail:K(e)})},providers:j(s)}},Y=e=>{const s=e.config.user.supertokens.recipes?.thirdPartyEmailPassword;return s&&typeof s=="function"?d.init(s(e)):d.init(X(e))},Z=()=>({}),x=e=>{const s=e.config.user.supertokens.recipes;return s&&s.userRoles?p.init(s.userRoles(e)):p.init(Z())},ee=e=>[T(e),Y(e),x(e)],se=e=>{const{config:s}=e;U.init({appInfo:{apiDomain:s.baseUrl,appName:s.appName,websiteDomain:s.appOrigin[0]},recipeList:ee(e),supertokens:{connectionURI:s.user.supertokens.connectionUri}})},re=S(async(e,s,r)=>{const{config:n,log:t}=e;t.info("Registering supertokens plugin"),se(e),e.setErrorHandler(v.errorHandler()),e.register(C,{origin:n.appOrigin,allowedHeaders:["Content-Type","st-auth-mode",...U.getAllCORSHeaders()],credentials:!0}),e.register(D),e.register(v.plugin),t.info("Registering supertokens plugin complete"),e.decorate("verifySession",L.verifySession),r()}),ne=async(e,s,r)=>{const{config:n,slonik:t}=s,o=(await y.getSession(s,v.wrapResponse(r),{sessionRequired:!1}))?.getUserId();if(o){const a=new g(n,t),u=await d.getUserById(o);if(u){let l=null;const{roles:f}=await p.getRolesForUser(o);try{l=await a.findById(o)}catch{}const m={...u,profile:l,roles:f};e.user=m}}},F=S(async(e,s,r)=>{const{mercurius:n}=e.config;await e.register(re),n.enabled&&await e.register(q),r()});F.updateContext=ne;const te={Query:{user:async(e,s,r)=>await new g(r.config,r.database).findById(s.id),users:async(e,s,r)=>await new g(r.config,r.database).list(s.limit,s.offset,s.filters?JSON.parse(JSON.stringify(s.filters)):void 0,s.sort?JSON.parse(JSON.stringify(s.sort)):void 0)}},ie=async(e,s,r)=>{const n="/users";e.get(n,{preHandler:e.verifySession()},async(t,i)=>{const o=new g(t.config,t.slonik),{limit:a,offset:u,filters:l,sort:f}=t.query,m=await o.list(a,u,l?JSON.parse(l):void 0,f?JSON.parse(f):void 0);i.send(m)}),r()};class w{config;database;constructor(s,r){this.config=s,this.database=r}changePassword=async(s,r,n)=>{const t=b(n,this.config);if(!t.success)return{status:"FIELD_ERROR",message:t.message};const i=await d.getUserById(s);if(r&&n)if(i)if((await d.emailPasswordSignIn(i.email,r)).status==="OK"){if(await d.updateEmailOrPassword({userId:s,password:n}))return await y.revokeAllSessionsForUser(s),{status:"OK"};throw{status:"FAILED",message:"Oops! Something went wrong, couldn't change password"}}else return{status:"INVALID_PASSWORD",message:"Invalid password"};else throw{status:"NOT_FOUND",message:"User not found"};else return{status:"FIELD_ERROR",message:"Password cannot be empty"}};getUserById=async s=>{const r=await d.getUserById(s),n=new g(this.config,this.database);let t=null;try{t=await n.findById(s)}catch{}const i=await p.getRolesForUser(s);return{email:r?.email,id:s,profile:t,roles:i.roles,timeJoined:r?.timeJoined}}}const oe={Mutation:{changePassword:async(e,s,r)=>{const n=new w(r.config,r.database);try{return r.user?.id?await n.changePassword(r.user?.id,s.oldPassword,s.newPassword):{status:"NOT_FOUND",message:"User not found"}}catch(t){r.app.log.error(t);const i=new P.ErrorWithProps("Oops, Something went wrong");return i.statusCode=500,i}}},Query:{me:async(e,s,r)=>{const n=new w(r.config,r.database);if(r.user?.id)return n.getUserById(r.user.id);{r.app.log.error("Cound not get user id from mercurius context");const t=new P.ErrorWithProps("Oops, Something went wrong");return t.statusCode=500,t}}}},ae=async(e,s,r)=>{const n="/change_password",t="/me";e.post(n,{preHandler:e.verifySession()},async(i,o)=>{try{const a=i.session,u=i.body,l=a&&a.getUserId();if(!l)throw new Error("User not found in session");const f=u.oldPassword??"",m=u.newPassword??"",ce=await new w(i.config,i.slonik).changePassword(l,f,m);o.send(ce)}catch(a){e.log.error(a),o.status(500),o.send({status:"ERROR",message:"Oops! Something went wrong",error:a})}}),e.get(t,{preHandler:e.verifySession()},async(i,o)=>{const a=new w(i.config,i.slonik),u=i.session?.getUserId();if(u)o.send(await a.getUserById(u));else throw e.log.error("Cound not get user id from session"),new Error("Oops, Something went wrong")}),r()};c.UserProfileService=g,c.UserService=w,c.default=F,c.userProfileResolver=te,c.userProfileRoutes=ie,c.userResolver=oe,c.userRoutes=ae,Object.defineProperties(c,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
