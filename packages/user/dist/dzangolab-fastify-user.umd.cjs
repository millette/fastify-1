(function(c,m){typeof exports=="object"&&typeof module<"u"?m(exports,require("@dzangolab/fastify-mercurius"),require("fastify-plugin"),require("mercurius"),require("mercurius-auth"),require("@fastify/cors"),require("@fastify/formbody"),require("supertokens-node"),require("supertokens-node/framework/fastify"),require("supertokens-node/recipe/session/framework/fastify"),require("supertokens-node/recipe/session"),require("supertokens-node/recipe/thirdpartyemailpassword"),require("@dzangolab/fastify-slonik"),require("validator"),require("zod"),require("supertokens-node/recipe/userroles"),require("@dzangolab/fastify-mailer")):typeof define=="function"&&define.amd?define(["exports","@dzangolab/fastify-mercurius","fastify-plugin","mercurius","mercurius-auth","@fastify/cors","@fastify/formbody","supertokens-node","supertokens-node/framework/fastify","supertokens-node/recipe/session/framework/fastify","supertokens-node/recipe/session","supertokens-node/recipe/thirdpartyemailpassword","@dzangolab/fastify-slonik","validator","zod","supertokens-node/recipe/userroles","@dzangolab/fastify-mailer"],m):(c=typeof globalThis<"u"?globalThis:c||self,m(c.DzangolabFastifyUser={},c.DzangolabFastifyMercurius,c.FastifyPlugin,c.Mercurius,c.MercuriusAuth,c.FastifyCors,c.FastifyFormbody,c.SupertokensNode,c.SupertokensFastify,c.SupertokensSessionFastify,c.SupertokensSession,c.SupertokensThirdPartyEmailPassword,c.DzangolabFastifySlonik,c.validator,c.zod,c.SupertokensUserRoles))})(this,function(c,m,y,P,C,L,q,v,U,_,w,l,E,k,R,g){"use strict";const A=y(async e=>{e.config.mercurius.enabled&&e.register(C,{async applyPolicy(r,t,i,o){if(!o.user){const n=new P.ErrorWithProps("unauthorized");return n.statusCode=200,n}return!0},authDirective:"auth"})}),T=()=>({}),$=e=>{const s=e.config.user.supertokens.recipes;return s&&s.session?w.init(s.session(e)):w.init(T())};class M extends E.DefaultSqlFactory{}const z=(e,s)=>R.z.string({required_error:e.required}).refine(r=>k.isEmail(r,s||{}),{message:e.invalid}),O={minLength:8,minLowercase:0,minUppercase:0,minNumbers:0,minSymbols:0,returnScore:!1,pointsPerUnique:1,pointsPerRepeat:.5,pointsForContainingLower:10,pointsForContainingUpper:10,pointsForContainingNumber:10,pointsForContainingSymbol:10},B=(e,s)=>{const r={...O,...s};return R.z.string({required_error:e.required}).refine(t=>k.isStrongPassword(t,r),{message:e.weak})},K=e=>{let s="Password is too weak";if(!e)return s;const r=[];if(e.minLength){const t=e.minLength;r.push(`minimum ${t} ${t>1?"characters":"character"}`)}if(e.minLowercase){const t=e.minLowercase;r.push(`minimum ${t} ${t>1?"lowercases":"lowercase"}`)}if(e.minUppercase){const t=e.minUppercase;r.push(`minimum ${t} ${t>1?"uppercases":"uppercase"}`)}if(e.minNumbers){const t=e.minNumbers;r.push(`minimum ${t} ${t>1?"numbers":"number"}`)}if(e.minSymbols){const t=e.minSymbols;r.push(`minimum ${t} ${t>1?"symbols":"symbol"}`)}if(r.length>0){s="Password should contain ";const t=r.pop();r.length>0&&(s+=r.join(", ")+" and "),s+=t}return s},b=(e,s)=>{const r=s.user.password,t=B({required:"Password is required",weak:K({...O,...r})},r).safeParse(e);return t.success?{success:!0}:{message:t.error.issues[0].message,success:!1}};class p extends E.BaseService{constructor(s,r){super(s,r)}static LIMIT_DEFAULT=20;static LIMIT_MAX=50;get table(){return this.config.user?.table?.name||"users"}get factory(){if(!this.table)throw new Error("Service table is not defined");return this._factory||(this._factory=new M(this)),this._factory}changePassword=async(s,r,t)=>{const i=b(t,this.config);if(!i.success)return{status:"FIELD_ERROR",message:i.message};const o=await l.getUserById(s);if(r&&t)if(o)if((await l.emailPasswordSignIn(o.email,r)).status==="OK"){if(await l.updateEmailOrPassword({userId:s,password:t}))return await w.revokeAllSessionsForUser(s),{status:"OK"};throw{status:"FAILED",message:"Oops! Something went wrong, couldn't change password"}}else return{status:"INVALID_PASSWORD",message:"Invalid password"};else throw{status:"NOT_FOUND",message:"User not found"};else return{status:"FIELD_ERROR",message:"Password cannot be empty"}}}const I=e=>e.toISOString().slice(0,19).replace("T"," "),H=(e,s)=>{const{config:r,log:t,slonik:i}=s;return async o=>{const n=await e.emailPasswordSignIn(o);if(n.status!=="OK")return n;const a=new p(r,i);let u;try{u=await a.update(n.user.id,{lastLoginAt:I(new Date)})}catch{if(!u)throw t.error(`Unable to update user ${n.user.id}`),new Error(`Unable to update user ${n.user.id}`)}return{status:"OK",user:{...n.user,...u}}}},F=async({fastify:e,subject:s,templateData:r={},templateName:t,to:i})=>{const{config:o,mailer:n,log:a}=e;return n.sendMail({subject:s,templateName:t,to:i,templateData:{appName:o.appName,...r}}).catch(u=>{throw a.error(u.stack),{name:"SEND_EMAIL",message:u.message,statusCode:500}})},W=(e,s)=>{const{config:r,log:t,slonik:i}=s;return async o=>{if(r.user.features?.signUp===!1)throw{name:"SIGN_UP_DISABLED",message:"SignUp feature is currently disabled",statusCode:404};const n=await e.emailPasswordSignUp(o);if(n.status==="OK"){const u=await new p(r,i).create({id:n.user.id,email:n.user.email});if(!u)throw t.error(`Unable to create user ${n.user.id}`),new Error(`Unable to create user ${n.user.id}`);n.user={...n.user,...u};const d=await g.addRoleToUser(n.user.id,r.user.role||"USER");d.status!=="OK"&&t.error(d.status)}if(r.user.supertokens.sendUserAlreadyExistsWarning&&n.status==="EMAIL_ALREADY_EXISTS_ERROR")try{await F({fastify:s,subject:"Duplicate Email Registration",templateData:{emailId:o.email},templateName:"duplicate-email-warning",to:o.email})}catch(a){t.error(a)}return n}},j=(e,s)=>{const r=z({invalid:"Email is invalid",required:"Email is required"},s.user.email).safeParse(e);return r.success?{success:!0}:{message:r.error.issues[0].message,success:!1}},J=e=>[{id:"email",validate:async s=>{const r=j(s,e);if(!r.success)return r.message}},{id:"password",validate:async s=>{const r=b(s,e);if(!r.success)return r.message}}],G=e=>{let s=[];if(typeof e.user.supertokens?.recipes?.thirdPartyEmailPassword=="object"){const t=e.user.supertokens?.recipes?.thirdPartyEmailPassword.signUpFeature?.formFields;t&&(s=[...t])}const r=new Set(s.map(t=>t.id));for(const t of J(e))r.has(t.id)||s.push(t);return s},V=e=>{let s;try{if(s=new URL(e).origin,!s||s==="null")throw new Error("Origin is empty")}catch{s=""}return s},Q=(e,s)=>{const r=s.config.appOrigin[0],t="/reset-password";return async i=>{const o=i.userContext._default.request.request,n=o.headers.referer||o.headers.origin||o.hostname,a=V(n)||r,u=i.passwordResetLink.replace(r+"/auth/reset-password",a+(s.config.user.supertokens.resetPasswordPath||t));await F({fastify:s,subject:"Reset Password",templateName:"reset-password",to:i.user.email,templateData:{passwordResetLink:u}})}},X=(e,s)=>{const{config:r,log:t}=s;return async i=>{if(!await l.getUserByThirdPartyInfo(i.thirdPartyId,i.thirdPartyUserId,i.userContext)&&r.user.features?.signUp===!1)throw{name:"SIGN_UP_DISABLED",message:"SignUp feature is currently disabled",statusCode:404};const n=await e.thirdPartySignInUp(i);if(n.status==="OK"&&n.createdNewUser){const a=await g.addRoleToUser(n.user.id,r.user.role||"USER");a.status!=="OK"&&t.error(a.status)}return n}},Y=(e,s)=>{const{config:r,log:t,slonik:i}=s;return async o=>{if(e.thirdPartySignInUpPOST===void 0)throw new Error("Should never come here");const n=await e.thirdPartySignInUpPOST(o);if(n.status==="OK"){const a=new p(r,i);let u;try{u=await(n.createdNewUser?a.create({id:n.user.id,email:n.user.email}):a.update(n.user.id,{lastLoginAt:I(new Date)}))}catch{if(!u)throw t.error(`Unable to create user ${n.user.id}`),new Error(`Unable to create user ${n.user.id}`)}return{status:"OK",createdNewUser:n.createdNewUser,user:{...n.user,...u},session:n.session,authCodeResponse:n.authCodeResponse}}return n}},Z=e=>{const{Apple:s,Facebook:r,Github:t,Google:i}=l,o=e.user.supertokens.providers,n=[],a=[{name:"google",initProvider:i},{name:"github",initProvider:t},{name:"facebook",initProvider:r},{name:"apple",initProvider:s}];for(const u of a)o?.[u.name]&&n.push(u.initProvider(o[u.name]));return n},x=e=>{const{config:s}=e;let r={};return typeof s.user.supertokens.recipes?.thirdPartyEmailPassword=="object"&&(r=s.user.supertokens.recipes.thirdPartyEmailPassword),{override:{apis:t=>{const i={};if(r.override?.apis){const o=r.override.apis;let n;for(n in o){const a=o[n];a&&(i[n]=a(t,e))}}return{...t,thirdPartySignInUpPOST:Y(t,e),...i}},functions:t=>{const i={};if(r.override?.functions){const o=r.override.functions;let n;for(n in o){const a=o[n];a&&(i[n]=a(t,e))}}return{...t,emailPasswordSignIn:H(t,e),emailPasswordSignUp:W(t,e),thirdPartySignInUp:X(t,e),...i}}},signUpFeature:{formFields:G(s)},emailDelivery:{override:t=>{let i;return r?.sendEmail&&(i=r.sendEmail),{...t,sendEmail:i?i(t,e):Q(t,e)}}},providers:Z(s)}},ee=e=>{const s=e.config.user.supertokens.recipes?.thirdPartyEmailPassword;return typeof s=="function"?l.init(s(e)):l.init(x(e))},se=()=>({}),re=e=>{const s=e.config.user.supertokens.recipes;return s&&s.userRoles?g.init(s.userRoles(e)):g.init(se())},te=e=>[$(e),ee(e),re(e)],ne=e=>{const{config:s}=e;v.init({appInfo:{apiDomain:s.baseUrl,appName:s.appName,websiteDomain:s.appOrigin[0]},recipeList:te(e),supertokens:{connectionURI:s.user.supertokens.connectionUri}})},ie=y(async(e,s,r)=>{const{config:t,log:i}=e;i.info("Registering supertokens plugin"),ne(e),e.setErrorHandler(U.errorHandler()),e.register(L,{origin:t.appOrigin,allowedHeaders:["Content-Type","st-auth-mode",...v.getAllCORSHeaders()],credentials:!0}),e.register(q),e.register(U.plugin),i.info("Registering supertokens plugin complete"),e.decorate("verifySession",_.verifySession),r()}),oe=async(e,s,r)=>{const{config:t,slonik:i}=s,n=(await w.getSession(s,U.wrapResponse(r),{sessionRequired:!1}))?.getUserId();if(n){const a=new p(t,i);let u=null;try{u=await a.findById(n)}catch{}if(!u)throw new Error("Unable to find user");const{roles:d}=await g.getRolesForUser(n);e.user=u,e.roles=d}},D=y(async(e,s,r)=>{const{mercurius:t}=e.config;await e.register(ie),t.enabled&&await e.register(A),r()});D.updateContext=oe;const ae={Mutation:{changePassword:async(e,s,r)=>{const t=new p(r.config,r.database);try{return r.user?.id?await t.changePassword(r.user?.id,s.oldPassword,s.newPassword):{status:"NOT_FOUND",message:"User not found"}}catch(i){r.app.log.error(i);const o=new P.ErrorWithProps("Oops, Something went wrong");return o.statusCode=500,o}}},Query:{me:async(e,s,r)=>{const t=new p(r.config,r.database);if(r.user?.id)return t.findById(r.user.id);{r.app.log.error("Could not able to get user id from mercurius context");const i=new P.ErrorWithProps("Oops, Something went wrong");return i.statusCode=500,i}},user:async(e,s,r)=>await new p(r.config,r.database).findById(s.id),users:async(e,s,r)=>await new p(r.config,r.database).list(s.limit,s.offset,s.filters?JSON.parse(JSON.stringify(s.filters)):void 0,s.sort?JSON.parse(JSON.stringify(s.sort)):void 0)}},ue=async(e,s,r)=>{const t="/change_password",i="/me",o="/users";e.get(o,{preHandler:e.verifySession()},async(n,a)=>{const u=new p(n.config,n.slonik),{limit:d,offset:f,filters:h,sort:S}=n.query,N=await u.list(d,f,h?JSON.parse(h):void 0,S?JSON.parse(S):void 0);a.send(N)}),e.post(t,{preHandler:e.verifySession()},async(n,a)=>{try{const u=n.session,d=n.body,f=u&&u.getUserId();if(!f)throw new Error("User not found in session");const h=d.oldPassword??"",S=d.newPassword??"",ce=await new p(n.config,n.slonik).changePassword(f,h,S);a.send(ce)}catch(u){e.log.error(u),a.status(500),a.send({status:"ERROR",message:"Oops! Something went wrong",error:u})}}),e.get(i,{preHandler:e.verifySession()},async(n,a)=>{const u=new p(n.config,n.slonik),d=n.session?.getUserId();if(d)a.send(await u.findById(d));else throw e.log.error("Could not able to get user id from session"),new Error("Oops, Something went wrong")}),r()};c.UserService=p,c.default=D,c.userResolver=ae,c.userRoutes=ue,Object.defineProperties(c,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
