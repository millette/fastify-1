(function(c,m){typeof exports=="object"&&typeof module<"u"?m(exports,require("@dzangolab/fastify-mercurius"),require("fastify-plugin"),require("mercurius"),require("mercurius-auth"),require("@fastify/cors"),require("@fastify/formbody"),require("supertokens-node"),require("supertokens-node/framework/fastify"),require("supertokens-node/recipe/session/framework/fastify"),require("supertokens-node/recipe/session"),require("supertokens-node/recipe/thirdpartyemailpassword"),require("@dzangolab/fastify-slonik"),require("supertokens-node/recipe/userroles"),require("@dzangolab/fastify-mailer"),require("validator"),require("zod")):typeof define=="function"&&define.amd?define(["exports","@dzangolab/fastify-mercurius","fastify-plugin","mercurius","mercurius-auth","@fastify/cors","@fastify/formbody","supertokens-node","supertokens-node/framework/fastify","supertokens-node/recipe/session/framework/fastify","supertokens-node/recipe/session","supertokens-node/recipe/thirdpartyemailpassword","@dzangolab/fastify-slonik","supertokens-node/recipe/userroles","@dzangolab/fastify-mailer","validator","zod"],m):(c=typeof globalThis<"u"?globalThis:c||self,m(c.DzangolabFastifyUser={},c.DzangolabFastifyMercurius,c.FastifyPlugin,c.Mercurius,c.MercuriusAuth,c.FastifyCors,c.FastifyFormbody,c.SupertokensNode,c.SupertokensFastify,c.SupertokensSessionFastify,c.SupertokensSession,c.SupertokensThirdPartyEmailPassword,c.DzangolabFastifySlonik,c.SupertokensUserRoles,c.DzangolabFastifyMailer,c.validator,c.zod))})(this,function(c,m,U,v,C,L,N,k,E,q,f,p,w,g,le,R,b){"use strict";const A=U(async e=>{e.config.mercurius.enabled&&e.register(C,{async applyPolicy(r,t,n,a){if(!a.user){const i=new v.ErrorWithProps("unauthorized");return i.statusCode=200,i}return!0},authDirective:"auth"})}),M=()=>({}),T=e=>{const s=e.config.user.supertokens.recipes;return s&&s.session?f.init(s.session(e)):f.init(M())};let $=class extends w.DefaultSqlFactory{};class h extends w.BaseService{static LIMIT_DEFAULT=20;static LIMIT_MAX=50;get table(){return this.config.user?.table?.name||"users"}get factory(){if(!this.table)throw new Error("Service table is not defined");return this._factory||(this._factory=new $(this)),this._factory}}const z=(e,s)=>{const{config:r,log:t,slonik:n}=s;return async a=>{const i=await e.emailPasswordSignIn(a);if(i.status!=="OK")return i;const u=new h(r,n);let o;if(o=await u.findById(i.user.id),!o&&(o=await u.create({id:i.user.id,email:i.user.email}),!o))throw t.error(`Unable to create user ${i.user.id}`),new Error(`Unable to create user ${i.user.id}`);return{status:"OK",user:{...i.user,...o}}}},O=async({fastify:e,subject:s,templateData:r={},templateName:t,to:n})=>{const{config:a,mailer:i,log:u}=e;return i.sendMail({subject:s,templateName:t,to:n,templateData:{appName:a.appName,...r}}).catch(o=>{throw u.error(o.stack),{name:"SEND_EMAIL",message:o.message,statusCode:500}})},B=(e,s)=>{const{config:r,log:t,slonik:n}=s;return async a=>{if(r.user.features?.signUp===!1)throw{name:"SIGN_UP_DISABLED",message:"SignUp feature is currently disabled",statusCode:404};const i=await e.emailPasswordSignUp(a);if(i.status==="OK"){const o=await new h(r,n).create({id:i.user.id,email:i.user.email});if(!o)throw t.error(`Unable to create user ${i.user.id}`),new Error(`Unable to create user ${i.user.id}`);i.user={...i.user,...o};const d=await g.addRoleToUser(i.user.id,r.user.role||"USER");d.status!=="OK"&&t.error(d.status)}if(r.user.supertokens.sendUserAlreadyExistsWarning&&i.status==="EMAIL_ALREADY_EXISTS_ERROR")try{await O({fastify:s,subject:"Duplicate Email Registration",templateData:{emailId:a.email},templateName:"duplicate-email-warning",to:a.email})}catch(u){t.error(u)}return i}},K=(e,s)=>b.z.string({required_error:e.required}).refine(r=>R.isEmail(r,s||{}),{message:e.invalid}),I={minLength:8,minLowercase:0,minUppercase:0,minNumbers:0,minSymbols:0,returnScore:!1,pointsPerUnique:1,pointsPerRepeat:.5,pointsForContainingLower:10,pointsForContainingUpper:10,pointsForContainingNumber:10,pointsForContainingSymbol:10},H=(e,s)=>{const r={...I,...s};return b.z.string({required_error:e.required}).refine(t=>R.isStrongPassword(t,r),{message:e.weak})},W=(e,s)=>{const r=K({invalid:"Email is invalid",required:"Email is required"},s.user.email).safeParse(e);return r.success?{success:!0}:{message:r.error.issues[0].message,success:!1}},j=e=>{let s="Password is too weak";if(!e)return s;const r=[];if(e.minLength){const t=e.minLength;r.push(`minimum ${t} ${t>1?"characters":"character"}`)}if(e.minLowercase){const t=e.minLowercase;r.push(`minimum ${t} ${t>1?"lowercases":"lowercase"}`)}if(e.minUppercase){const t=e.minUppercase;r.push(`minimum ${t} ${t>1?"uppercases":"uppercase"}`)}if(e.minNumbers){const t=e.minNumbers;r.push(`minimum ${t} ${t>1?"numbers":"number"}`)}if(e.minSymbols){const t=e.minSymbols;r.push(`minimum ${t} ${t>1?"symbols":"symbol"}`)}if(r.length>0){s="Password should contain ";const t=r.pop();r.length>0&&(s+=r.join(", ")+" and "),s+=t}return s},F=(e,s)=>{const r=s.user.password,t=H({required:"Password is required",weak:j({...I,...r})},r).safeParse(e);return t.success?{success:!0}:{message:t.error.issues[0].message,success:!1}},J=e=>[{id:"email",validate:async s=>{const r=W(s,e);if(!r.success)return r.message}},{id:"password",validate:async s=>{const r=F(s,e);if(!r.success)return r.message}}],G=e=>{let s=[];if(typeof e.user.supertokens?.recipes?.thirdPartyEmailPassword=="object"){const t=e.user.supertokens?.recipes?.thirdPartyEmailPassword.signUpFeature?.formFields;t&&(s=[...t])}const r=new Set(s.map(t=>t.id));for(const t of J(e))r.has(t.id)||s.push(t);return s},V=e=>{let s;try{if(s=new URL(e).origin,!s||s==="null")throw new Error("Origin is empty")}catch{s=""}return s},X=(e,s)=>{const r=s.config.appOrigin[0],t="/reset-password";return async n=>{const a=n.userContext._default.request.request,i=a.headers.referer||a.headers.origin||a.hostname,u=V(i)||r,o=n.passwordResetLink.replace(r+"/auth/reset-password",u+(s.config.user.supertokens.resetPasswordPath||t));await O({fastify:s,subject:"Reset Password",templateName:"reset-password",to:n.user.email,templateData:{passwordResetLink:o}})}},Q=(e,s)=>{const{config:r,log:t}=s;return async n=>{if(!await p.getUserByThirdPartyInfo(n.thirdPartyId,n.thirdPartyUserId,n.userContext)&&r.user.features?.signUp===!1)throw{name:"SIGN_UP_DISABLED",message:"SignUp feature is currently disabled",statusCode:404};const i=await e.thirdPartySignInUp(n);if(i.status==="OK"&&i.createdNewUser){const u=await g.addRoleToUser(i.user.id,r.user.role||"USER");u.status!=="OK"&&t.error(u.status)}return i}},Y=(e,s)=>{const{config:r,log:t,slonik:n}=s;return async a=>{if(e.thirdPartySignInUpPOST===void 0)throw new Error("Should never come here");const i=await e.thirdPartySignInUpPOST(a);if(i.status==="OK"){const u=new h(r,n);let o;if(o=await u.findById(i.user.id),!o&&(o=await u.create({id:i.user.id,email:i.user.email}),!o))throw t.error(`Unable to create user ${i.user.id}`),new Error(`Unable to create user ${i.user.id}`);return{status:"OK",createdNewUser:i.createdNewUser,user:{...i.user,...o},session:i.session,authCodeResponse:i.authCodeResponse}}return i}},Z=e=>{const{Apple:s,Facebook:r,Github:t,Google:n}=p,a=e.user.supertokens.providers,i=[],u=[{name:"google",initProvider:n},{name:"github",initProvider:t},{name:"facebook",initProvider:r},{name:"apple",initProvider:s}];for(const o of u)a?.[o.name]&&i.push(o.initProvider(a[o.name]));return i},x=e=>{const{config:s}=e;let r={};return typeof s.user.supertokens.recipes?.thirdPartyEmailPassword=="object"&&(r=s.user.supertokens.recipes.thirdPartyEmailPassword),{override:{apis:t=>{const n={};if(r.override?.apis){const a=r.override.apis;let i;for(i in a){const u=a[i];u&&(n[i]=u(t,e))}}return{...t,thirdPartySignInUpPOST:Y(t,e),...n}},functions:t=>{const n={};if(r.override?.functions){const a=r.override.functions;let i;for(i in a){const u=a[i];u&&(n[i]=u(t,e))}}return{...t,emailPasswordSignIn:z(t,e),emailPasswordSignUp:B(t,e),thirdPartySignInUp:Q(t,e),...n}}},signUpFeature:{formFields:G(s)},emailDelivery:{override:t=>{let n;return r?.sendEmail&&(n=r.sendEmail),{...t,sendEmail:n?n(t,e):X(t,e)}}},providers:Z(s)}},ee=e=>{const s=e.config.user.supertokens.recipes?.thirdPartyEmailPassword;return typeof s=="function"?p.init(s(e)):p.init(x(e))},se=()=>({}),re=e=>{const s=e.config.user.supertokens.recipes;return s&&s.userRoles?g.init(s.userRoles(e)):g.init(se())},te=e=>[T(e),ee(e),re(e)],ie=e=>{const{config:s}=e;k.init({appInfo:{apiDomain:s.baseUrl,appName:s.appName,websiteDomain:s.appOrigin[0]},recipeList:te(e),supertokens:{connectionURI:s.user.supertokens.connectionUri}})},ne=U(async(e,s,r)=>{const{config:t,log:n}=e;n.info("Registering supertokens plugin"),ie(e),e.setErrorHandler(E.errorHandler()),e.register(L,{origin:t.appOrigin,allowedHeaders:["Content-Type","st-auth-mode",...k.getAllCORSHeaders()],credentials:!0}),e.register(N),e.register(E.plugin),n.info("Registering supertokens plugin complete"),e.decorate("verifySession",q.verifySession),r()}),oe=async(e,s,r)=>{const{config:t,slonik:n}=s,i=(await f.getSession(s,E.wrapResponse(r),{sessionRequired:!1}))?.getUserId();if(i){const u=new h(t,n);let o=null;try{o=await u.findById(i)}catch{}if(!o)throw new Error("Unable to find user");const{roles:d}=await g.getRolesForUser(i);e.user=o,e.roles=d}},D=U(async(e,s,r)=>{const{mercurius:t}=e.config;await e.register(ne),t.enabled&&await e.register(A),r()});D.updateContext=oe;class ae extends w.DefaultSqlFactory{}class l extends w.BaseService{constructor(s,r){super(s,r)}static LIMIT_DEFAULT=20;static LIMIT_MAX=50;get table(){return this.config.user?.table?.name||"users"}get factory(){if(!this.table)throw new Error("Service table is not defined");return this._factory||(this._factory=new ae(this)),this._factory}changePassword=async(s,r,t)=>{const n=F(t,this.config);if(!n.success)return{status:"FIELD_ERROR",message:n.message};const a=await p.getUserById(s);if(r&&t)if(a)if((await p.emailPasswordSignIn(a.email,r)).status==="OK"){if(await p.updateEmailOrPassword({userId:s,password:t}))return await f.revokeAllSessionsForUser(s),{status:"OK"};throw{status:"FAILED",message:"Oops! Something went wrong, couldn't change password"}}else return{status:"INVALID_PASSWORD",message:"Invalid password"};else throw{status:"NOT_FOUND",message:"User not found"};else return{status:"FIELD_ERROR",message:"Password cannot be empty"}}}const ue={Mutation:{changePassword:async(e,s,r)=>{const t=new l(r.config,r.database);try{return r.user?.id?await t.changePassword(r.user?.id,s.oldPassword,s.newPassword):{status:"NOT_FOUND",message:"User not found"}}catch(n){r.app.log.error(n);const a=new v.ErrorWithProps("Oops, Something went wrong");return a.statusCode=500,a}}},Query:{me:async(e,s,r)=>{const t=new l(r.config,r.database);if(r.user?.id)return t.findById(r.user.id);{r.app.log.error("Could not able to get user id from mercurius context");const n=new v.ErrorWithProps("Oops, Something went wrong");return n.statusCode=500,n}},user:async(e,s,r)=>await new l(r.config,r.database).findById(s.id),users:async(e,s,r)=>await new l(r.config,r.database).list(s.limit,s.offset,s.filters?JSON.parse(JSON.stringify(s.filters)):void 0,s.sort?JSON.parse(JSON.stringify(s.sort)):void 0)}},ce=async(e,s,r)=>{const t="/change_password",n="/me",a="/users";e.get(a,{preHandler:e.verifySession()},async(i,u)=>{const o=new l(i.config,i.slonik),{limit:d,offset:y,filters:S,sort:P}=i.query,_=await o.list(d,y,S?JSON.parse(S):void 0,P?JSON.parse(P):void 0);u.send(_)}),e.post(t,{preHandler:e.verifySession()},async(i,u)=>{try{const o=i.session,d=i.body,y=o&&o.getUserId();if(!y)throw new Error("User not found in session");const S=d.oldPassword??"",P=d.newPassword??"",de=await new l(i.config,i.slonik).changePassword(y,S,P);u.send(de)}catch(o){e.log.error(o),u.status(500),u.send({status:"ERROR",message:"Oops! Something went wrong",error:o})}}),e.get(n,{preHandler:e.verifySession()},async(i,u)=>{const o=new l(i.config,i.slonik),d=i.session?.getUserId();if(d)u.send(await o.findById(d));else throw e.log.error("Could not able to get user id from session"),new Error("Oops, Something went wrong")}),r()};c.UserService=l,c.default=D,c.userResolver=ue,c.userRoutes=ce,Object.defineProperties(c,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
